{"remainingRequest":"F:\\sunrisers\\medicode\\medicode\\adminPortal\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!F:\\sunrisers\\medicode\\medicode\\adminPortal\\src\\pages\\Dashboard\\components\\MainChart\\MainChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"F:\\sunrisers\\medicode\\medicode\\adminPortal\\src\\pages\\Dashboard\\components\\MainChart\\MainChart.vue","mtime":1583767198581},{"path":"F:\\sunrisers\\medicode\\medicode\\adminPortal\\node_modules\\babel-loader\\lib\\index.js","mtime":1591157735766},{"path":"F:\\sunrisers\\medicode\\medicode\\adminPortal\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1591157758729},{"path":"F:\\sunrisers\\medicode\\medicode\\adminPortal\\node_modules\\vue-loader\\lib\\index.js","mtime":1591157760591}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport $ from 'jquery';\nimport Widget from '@/components/Widget/Widget';\n\n/* eslint-disable */\nimport 'imports-loader?jQuery=jquery,this=>window!flot';\nimport 'imports-loader?jQuery=jquery,this=>window!flot/jquery.flot.selection.js';\nimport 'imports-loader?jQuery=jquery,this=>window!flot/jquery.flot.resize';\n/* eslint-enable */\n\nexport default {\n  name: 'MainChart',\n  components: { Widget },\n  data() {\n    return {\n      chartLegend: $('#main-chart .chart-legend'),\n    };\n  },\n  methods: {\n    getMainChartData() {\n      function generateRandomPicks(minPoint, maxPoint, picksAmount, xMax) {\n        let x = 0;\n        let y = 0;\n        const result = [];\n        const xStep = 1;\n        const smoothness = 0.3;\n        const pointsPerPick = Math.ceil(xMax / ((picksAmount * 2) + 1) / 2);\n\n        const maxValues = [];\n        const minValues = [];\n\n        for (let i = 0; i < picksAmount; i += 1) {\n          const minResult = minPoint + Math.random();\n          const maxResult = maxPoint - Math.random();\n\n          minValues.push(minResult);\n          maxValues.push(maxResult);\n        }\n\n        let localMax = maxValues.shift(0);\n        let localMin = 0;\n        let yStep = parseFloat(((localMax - localMin) / pointsPerPick).toFixed(2));\n\n        for (let j = 0; j < Math.ceil(xMax); j += 1) {\n          result.push([x, y]);\n\n          if ((y + yStep >= localMax) || (y + yStep <= localMin)) {\n            y += yStep * smoothness;\n          } else if ((result[result.length - 1][1] === localMax)\n          || (result[result.length - 1][1] === localMin)) {\n            y += yStep * smoothness;\n          } else {\n            y += yStep;\n          }\n\n          if (y > localMax) {\n            y = localMax;\n          } else if (y < localMin) {\n            y = localMin;\n          }\n\n          if (y === localMin) {\n            localMax = maxValues.shift(0) || localMax;\n\n            const share = (localMax - localMin) / localMax;\n            const p = share > 0.5\n              ? Math.round(pointsPerPick * 1.2)\n              : Math.round(pointsPerPick * share);\n\n            yStep = parseFloat(((localMax - localMin) / p).toFixed(2));\n            yStep *= Math.abs(yStep);\n          }\n\n          if (y === localMax) {\n            localMin = minValues.shift(0) || localMin;\n\n            const share = (localMax - localMin) / localMax;\n            const p = share > 0.5\n              ? Math.round(pointsPerPick * 1.5)\n              : Math.round(pointsPerPick * 0.5);\n\n            yStep = parseFloat(((localMax - localMin) / p).toFixed(2));\n            yStep *= -1;\n          }\n\n          x += xStep;\n        }\n\n        return result;\n      }\n\n      const d1 = generateRandomPicks(0.2, 3, 4, 90);\n      const d2 = generateRandomPicks(0.4, 3.8, 4, 90);\n      const d3 = generateRandomPicks(0.2, 4.2, 3, 90);\n\n      return [d1, d2, d3];\n    },\n    onDrawHook() {\n      this.$chartLegend\n        .find('.legendColorBox > div')\n        .css({\n          border: 15,\n          borderRadius: 0,\n          paddingTop: 5,\n          display: 'flex',\n          justifyContent: 'center',\n        })\n        .children('div')\n        .css({\n          borderWidth: 1,\n          borderRadius: 0,\n          width: 30,\n        });\n\n      this.$chartLegend.find('tbody td').css({\n        paddingLeft: 10,\n        paddingRight: 10,\n        textAlign: 'center',\n      });\n\n      const labels = this.$chartLegend.find('.legendLabel').detach();\n      this.$chartLegend.find('tbody').prepend('<tr></tr>');\n      this.$chartLegend.find('tbody tr:eq(0)').append(labels);\n    },\n    initChart() {\n      const data = this.getMainChartData();\n\n      const ticks = ['Dec 19', 'Dec 25', 'Dec 31', 'Jan 10', 'Jan 14',\n        'Jan 20', 'Jan 27', 'Jan 30', 'Feb 2', 'Feb 8', 'Feb 15',\n        'Feb 22', 'Feb 28', 'Mar 7', 'Mar 17'];\n\n      // check the screen size and either show tick for every 4th tick on large screens, or\n      // every 8th tick on mobiles\n      const tickInterval = screen.width < 500 ? 10 : 6; // eslint-disable-line\n      let counter = 0;\n\n      return $.plot(this.$chartContainer, [{\n        width: '100%',\n        label: 'Saturday',\n        data: data[0],\n        lines: {\n          show: true,\n          fill: 0.3,\n          lineWidth:0,\n        },\n        points: {\n          fillColor: '#A7BEFF',\n          symbol: (ctx, x, y) => {\n            // count for every 8nd point to show on line\n            if (counter % 8 === 0) { ctx.arc(x, y, 2, 0, Math.PI * 2, false); }\n\n            counter += 1;\n          },\n        },\n        shadowSize: 0,\n      }, {\n        label: 'Monday',\n        data: data[1],\n        points: {\n          fillColor: '#3abf94',\n        },\n        lines: {\n          show: true,\n          fill: false,\n          lineWidth:.4,\n        },\n        shadowSize: 0,\n      }, {\n        label: 'Tuesday',\n        data: data[2],\n        lines: {\n          show: true,\n          lineWidth: 2,\n        },\n        points: {\n          fillColor: '#f55d5d',\n        },\n        shadowSize: 0,\n      }], {\n        xaxis: {\n          tickColor: 'rgba(255,255,255,.04)',\n          tickSize: tickInterval,\n          color: '#fff',\n          tickFormatter: i => ticks[i / tickInterval],\n          font: {\n            lineHeight: 11,\n            weight: 400,\n          },\n        },\n        yaxis: {\n          tickColor: 'rgba(255,255,255,.5)',\n          color: '#fff',\n          max: 5,\n          font: {\n            lineHeight: 11,\n            weight: 400,\n          },\n        },\n        points: {\n          show: true,\n          fill: true,\n          lineWidth: 1,\n          radius: 1,\n          symbol: (ctx, x, y) => {\n            // show every 5th point on line\n            if (counter % 5 === 0) { ctx.arc(x, y, 2, 0, Math.PI * 2, false); }\n\n            counter += 1;\n          },\n        },\n        grid: {\n          backgroundColor: { colors: ['transparent', 'transparent'] },\n          borderWidth: 0,\n          margin: 0,\n          minBorderMargin: 0,\n          labelMargin: 20,\n          hoverable: true,\n          clickable: true,\n          mouseActiveRadius: 6,\n        },\n        legend: {\n          noColumns: 3,\n          container: $('#main-chart .chart-legend'),\n        },\n        colors: ['#E2E1FF', '#3abf94', '#ffc247'],\n        hooks: {\n          draw: [this.onDrawHook.bind(this)],\n        },\n      });\n    },\n    initEventListeners() {\n      const self = this;\n\n      this.$chartContainer.on('plothover', (event, pos, item) => {\n        if (item) {\n          const x = item.datapoint[0].toFixed(2);\n          const y = item.datapoint[1].toFixed(2);\n\n          self.$chartTooltip.html(`${item.series.label} at ${x} : ${y}`)\n            .css({\n              top: (item.pageY + 5) - window.scrollY,\n              left: (item.pageX + 5) - window.scrollX,\n            })\n            .fadeIn(200);\n        } else {\n          self.$chartTooltip.hide();\n        }\n      });\n    },\n  },\n  mounted() {\n    this.$chartContainer = $(this.$refs.chartContainer);\n    this.$chartLegend = $('#main-chart  .chart-legend');\n    this.$chartTooltip = $(this.$refs.chartTooltip);\n\n    this.initChart();\n    this.initEventListeners();\n  },\n};\n",{"version":3,"sources":["MainChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"MainChart.vue","sourceRoot":"src\\pages\\Dashboard\\components\\MainChart","sourcesContent":["<template>\n  <Widget\n    bodyClass=\"mt\"\n    class=\"mb-xlg\"\n    id=\"main-chart\"\n    title=\"\n        <div class='row'>\n          <div class='col-sm-5 col-xs-12'>\n            <h5>\n             Weekly Impression <span class='fw-semi-bold'>Line Chart</span>\n            </h5>\n          </div>\n          <div class='col-xs-12 col-sm-7'>\n            <div class='chart-legend' />\n          </div>\n        </div>\n      \"\n      customHeader\n    collapse close\n    >\n    <div ref=\"chartContainer\" style=\"width: 100%; height: 250px\" />\n    <div class=\"chart-tooltip\" ref=\"chartTooltip\" />\n  </Widget>\n</template>\n\n<script>\nimport $ from 'jquery';\nimport Widget from '@/components/Widget/Widget';\n\n/* eslint-disable */\nimport 'imports-loader?jQuery=jquery,this=>window!flot';\nimport 'imports-loader?jQuery=jquery,this=>window!flot/jquery.flot.selection.js';\nimport 'imports-loader?jQuery=jquery,this=>window!flot/jquery.flot.resize';\n/* eslint-enable */\n\nexport default {\n  name: 'MainChart',\n  components: { Widget },\n  data() {\n    return {\n      chartLegend: $('#main-chart .chart-legend'),\n    };\n  },\n  methods: {\n    getMainChartData() {\n      function generateRandomPicks(minPoint, maxPoint, picksAmount, xMax) {\n        let x = 0;\n        let y = 0;\n        const result = [];\n        const xStep = 1;\n        const smoothness = 0.3;\n        const pointsPerPick = Math.ceil(xMax / ((picksAmount * 2) + 1) / 2);\n\n        const maxValues = [];\n        const minValues = [];\n\n        for (let i = 0; i < picksAmount; i += 1) {\n          const minResult = minPoint + Math.random();\n          const maxResult = maxPoint - Math.random();\n\n          minValues.push(minResult);\n          maxValues.push(maxResult);\n        }\n\n        let localMax = maxValues.shift(0);\n        let localMin = 0;\n        let yStep = parseFloat(((localMax - localMin) / pointsPerPick).toFixed(2));\n\n        for (let j = 0; j < Math.ceil(xMax); j += 1) {\n          result.push([x, y]);\n\n          if ((y + yStep >= localMax) || (y + yStep <= localMin)) {\n            y += yStep * smoothness;\n          } else if ((result[result.length - 1][1] === localMax)\n          || (result[result.length - 1][1] === localMin)) {\n            y += yStep * smoothness;\n          } else {\n            y += yStep;\n          }\n\n          if (y > localMax) {\n            y = localMax;\n          } else if (y < localMin) {\n            y = localMin;\n          }\n\n          if (y === localMin) {\n            localMax = maxValues.shift(0) || localMax;\n\n            const share = (localMax - localMin) / localMax;\n            const p = share > 0.5\n              ? Math.round(pointsPerPick * 1.2)\n              : Math.round(pointsPerPick * share);\n\n            yStep = parseFloat(((localMax - localMin) / p).toFixed(2));\n            yStep *= Math.abs(yStep);\n          }\n\n          if (y === localMax) {\n            localMin = minValues.shift(0) || localMin;\n\n            const share = (localMax - localMin) / localMax;\n            const p = share > 0.5\n              ? Math.round(pointsPerPick * 1.5)\n              : Math.round(pointsPerPick * 0.5);\n\n            yStep = parseFloat(((localMax - localMin) / p).toFixed(2));\n            yStep *= -1;\n          }\n\n          x += xStep;\n        }\n\n        return result;\n      }\n\n      const d1 = generateRandomPicks(0.2, 3, 4, 90);\n      const d2 = generateRandomPicks(0.4, 3.8, 4, 90);\n      const d3 = generateRandomPicks(0.2, 4.2, 3, 90);\n\n      return [d1, d2, d3];\n    },\n    onDrawHook() {\n      this.$chartLegend\n        .find('.legendColorBox > div')\n        .css({\n          border: 15,\n          borderRadius: 0,\n          paddingTop: 5,\n          display: 'flex',\n          justifyContent: 'center',\n        })\n        .children('div')\n        .css({\n          borderWidth: 1,\n          borderRadius: 0,\n          width: 30,\n        });\n\n      this.$chartLegend.find('tbody td').css({\n        paddingLeft: 10,\n        paddingRight: 10,\n        textAlign: 'center',\n      });\n\n      const labels = this.$chartLegend.find('.legendLabel').detach();\n      this.$chartLegend.find('tbody').prepend('<tr></tr>');\n      this.$chartLegend.find('tbody tr:eq(0)').append(labels);\n    },\n    initChart() {\n      const data = this.getMainChartData();\n\n      const ticks = ['Dec 19', 'Dec 25', 'Dec 31', 'Jan 10', 'Jan 14',\n        'Jan 20', 'Jan 27', 'Jan 30', 'Feb 2', 'Feb 8', 'Feb 15',\n        'Feb 22', 'Feb 28', 'Mar 7', 'Mar 17'];\n\n      // check the screen size and either show tick for every 4th tick on large screens, or\n      // every 8th tick on mobiles\n      const tickInterval = screen.width < 500 ? 10 : 6; // eslint-disable-line\n      let counter = 0;\n\n      return $.plot(this.$chartContainer, [{\n        width: '100%',\n        label: 'Saturday',\n        data: data[0],\n        lines: {\n          show: true,\n          fill: 0.3,\n          lineWidth:0,\n        },\n        points: {\n          fillColor: '#A7BEFF',\n          symbol: (ctx, x, y) => {\n            // count for every 8nd point to show on line\n            if (counter % 8 === 0) { ctx.arc(x, y, 2, 0, Math.PI * 2, false); }\n\n            counter += 1;\n          },\n        },\n        shadowSize: 0,\n      }, {\n        label: 'Monday',\n        data: data[1],\n        points: {\n          fillColor: '#3abf94',\n        },\n        lines: {\n          show: true,\n          fill: false,\n          lineWidth:.4,\n        },\n        shadowSize: 0,\n      }, {\n        label: 'Tuesday',\n        data: data[2],\n        lines: {\n          show: true,\n          lineWidth: 2,\n        },\n        points: {\n          fillColor: '#f55d5d',\n        },\n        shadowSize: 0,\n      }], {\n        xaxis: {\n          tickColor: 'rgba(255,255,255,.04)',\n          tickSize: tickInterval,\n          color: '#fff',\n          tickFormatter: i => ticks[i / tickInterval],\n          font: {\n            lineHeight: 11,\n            weight: 400,\n          },\n        },\n        yaxis: {\n          tickColor: 'rgba(255,255,255,.5)',\n          color: '#fff',\n          max: 5,\n          font: {\n            lineHeight: 11,\n            weight: 400,\n          },\n        },\n        points: {\n          show: true,\n          fill: true,\n          lineWidth: 1,\n          radius: 1,\n          symbol: (ctx, x, y) => {\n            // show every 5th point on line\n            if (counter % 5 === 0) { ctx.arc(x, y, 2, 0, Math.PI * 2, false); }\n\n            counter += 1;\n          },\n        },\n        grid: {\n          backgroundColor: { colors: ['transparent', 'transparent'] },\n          borderWidth: 0,\n          margin: 0,\n          minBorderMargin: 0,\n          labelMargin: 20,\n          hoverable: true,\n          clickable: true,\n          mouseActiveRadius: 6,\n        },\n        legend: {\n          noColumns: 3,\n          container: $('#main-chart .chart-legend'),\n        },\n        colors: ['#E2E1FF', '#3abf94', '#ffc247'],\n        hooks: {\n          draw: [this.onDrawHook.bind(this)],\n        },\n      });\n    },\n    initEventListeners() {\n      const self = this;\n\n      this.$chartContainer.on('plothover', (event, pos, item) => {\n        if (item) {\n          const x = item.datapoint[0].toFixed(2);\n          const y = item.datapoint[1].toFixed(2);\n\n          self.$chartTooltip.html(`${item.series.label} at ${x} : ${y}`)\n            .css({\n              top: (item.pageY + 5) - window.scrollY,\n              left: (item.pageX + 5) - window.scrollX,\n            })\n            .fadeIn(200);\n        } else {\n          self.$chartTooltip.hide();\n        }\n      });\n    },\n  },\n  mounted() {\n    this.$chartContainer = $(this.$refs.chartContainer);\n    this.$chartLegend = $('#main-chart  .chart-legend');\n    this.$chartTooltip = $(this.$refs.chartTooltip);\n\n    this.initChart();\n    this.initEventListeners();\n  },\n};\n</script>\n"]}]}